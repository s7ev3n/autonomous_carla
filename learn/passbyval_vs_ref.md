# C++基础

## 1.值传递，引用传递，指针传递
>Difference Between **Pass By Value, Pass By Reference, and Pass By Pointer**

### 1.1 **TD;LR:**
1. **值传递**(Pass by Value)：形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。
2. **指针传递**(Pass by Pointer)：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。
3. **引用传递**(Pass by Reference)：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

下面的简单例子：
```c++
#include<iostream>
using namespace std;
//值传递
void passbyVal(int n){
    cout<<"值传递--函数操作地址"<<&n<<endl;         //显示的是拷贝的地址而不是源地址 
    n++;
}

//引用传递
void passbyRef(int & n){
    cout<<"引用传递--函数操作地址"<<&n<<endl; 
    n++;
}
 //指针传递
void passbyPtr(int *n){
     cout<<"指针传递--函数操作地址 "<<n<<endl; 
    *n=*n+1;
 } 
int main(){
    int n=10;
    cout<<"实参的地址"<<&n<<endl;
    passbyVal(n);
    cout<< "after passbyVal() n=" <<n<<endl;
    passbyRef(n);
    cout<<"after passbyRef() n="<<n<<endl;
    passbyPtr(&n);
    cout<<"after passbyPtr() n="<<n<<endl;
```

### 1.2 引用，引用与指针
#### **引用是啥：引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用&代替了\*。**
例子1：
```c++
Point p1(10,10);
Point &p2 = p1; 
//定义了p2为p1的引用。通过这样的定义，pt1和pt2表示同一对象。
//需要特别强调的是引用并不产生对象的副本，仅仅是对象的同义词。因此，当下面的语句执行后：
p1.offset（2，2）；
//pt1和pt2都具有（12，12）的值。
//引用必须在定义时马上被初始化，因为它必须是某个东西的同义词。你不能先定义一个引用后才
//初始化它。例如下面语句是非法的：
Point &p3；//This is illegal
p3=p1；//This is illegal
```
例子2:
```c++
int a;  int &ra=a;  //定义引用ra,它是变量a的引用，即别名
// （1）&在此不是求地址运算，而是起标识作用。
// （2）类型标识符是指目标变量的类型。
// （3）声明引用时，必须同时对其进行初始化。
// （4）引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。ra=1; 等价于 a=1; 
// （5）声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。&ra与&a相等。
// （6）不能建立数组的引用。因为数组是一个由若干个元素所成的集合，所以无法建立一个数组的别名。
// （7）不能建立引用的引用，不能建立指向引用的指针。因为引用不是一种数据类型！！所以没有引用的引用，没有引用的指针。

// 例如：
　　int n；
　　int &&r=n；//错误，编译系统把"int &"看成一体，把"&r"看成一体，即建立了引用的引用，引用的对象应当是某种数据类型的变量
　　int &*p=n;//错误，编译系统把"int &"看成一体，把" *p "看成一体，即建立了指向引用的指针，指针只能指向某种数据类型的变量

//（8）值得一提的是，可以建立指针的引用，例如：
    int *p;
    int *&q=p;//正确，编译系统把" int * "看成一体，把"&q"看成一体，即建立指针p的引用，亦即给指针p起别名q。

```


#### **引用与指针**
- 不存在空引用。引用必须连接到一块合法的内存。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。

**指针传递与引用传递的区别**
上面例子看上去，指针传递和引用传递非常相似，因为实参的值在传进函数后都发生了改变。
[C++中引用传递与指针传递区别](https://xinklabi.iteye.com/blog/653643):
“指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变）

而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。”
[我并不是特别理解]

#### 引用作为返回值

要以引用返回函数值，则函数定义时要按以下格式：
类型标识符 &函数名（形参列表及类型说明）
{函数体}

说明：
（1）以引用返回函数值，定义函数时需要在函数名前加&
（2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。

[例子：](https://www.cnblogs.com/xiaofengkang/archive/2011/05/16/2048262.html)
```c++
#include <iostream.h>
float  temp;  //定义全局变量temp
float  fn1(float r);  //声明函数fn1
float  &fn2(float r);  //声明函数fn2

float  fn1(float r)  //定义函数fn1，它以返回值的方法返回函数值
{ 
　temp=(float)(r*r*3.14); 
　return temp; 
}

float &fn2(float r)  //定义函数fn2，它以引用方式返回函数值
{ 
　temp=(float)(r*r*3.14); 
　return temp;
}

void main()  //主函数
{ 
　float a=fn1(10.0);  //第1种情况，系统生成要返回值的副本（即临时变量）
　float &b=fn1(10.0);  //第2种情况，可能会出错（不同 C++系统有不同规定）
　//不能从被调函数中返回一个临时变量或局部变量的引用
　float c=fn2(10.0);  //第3种情况，系统不生成返回值的副本
　//可以从被调函数中返回一个全局变量的引用
　float &d=fn2(10.0);  //第4种情况，系统不生成返回值的副本
　//可以从被调函数中返回一个全局变量的引用
　cout<<a<<c<<d;
} 
```
